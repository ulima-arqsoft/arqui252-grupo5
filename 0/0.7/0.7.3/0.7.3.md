> [0. Acerca del Grupo](../../0.md) › [0.7. Trabajo Individual (Patrones Cloud)](../0.7.md) › [0.7.3. Integrante 3](0.7.3.md)

# 0.7.3. Leonardo Salazar

# Desarrollo del patrón: Disyuntor (circuit breaker)

### Problema

En sistemas distribuidos o basados en microservicios, uno de los principales desafíos es manejar las fallas intermitentes o caídas temporales de servicios externos, como APIs de terceros, bases de datos o pasarelas de pago.  
Cuando un servicio externo deja de responder, las aplicaciones suelen seguir enviando solicitudes en bucle, lo que consume recursos innecesariamente, genera bloqueos, aumenta la latencia y puede provocar una caída en cascada del sistema.


---

### Solución

El patrón **disyuntor (circuit breaker)** propone un mecanismo que supervisa las llamadas a servicios externos y abre el circuito cuando detecta un número determinado de fallos consecutivos.  
Al abrirse, el sistema bloquea temporalmente las nuevas solicitudes hacia el servicio fallido y devuelve una respuesta controlada o fallback.

Después de un tiempo preconfigurado, el circuito entra en modo semiabierto y permite una llamada de prueba:  
- Si la llamada tiene éxito, el circuito vuelve a cerrarse.  
- Si falla, se mantiene abierto por otro intervalo.

De esta manera:
- Se evita la sobrecarga del servicio externo.  
- Se protege la estabilidad interna del sistema.  
- Se mantiene la experiencia del usuario con respuestas predecibles y seguras.

---

### Casos de Aplicación

**Aplicaciones Fintech o E-commerce:**  
Plataformas que procesan pagos con servicios externos (Stripe, PayPal, MercadoPago) usan disyuntores para evitar que la caída de la pasarela afecte toda la aplicación.

**Sistemas de reservas o boletaje:**  
Cuando una API de terceros (aerolínea, hotel) está fuera de servicio, el disyuntor permite mostrar un mensaje al usuario sin detener el resto del sistema.

**Startups SaaS con microservicios:**  
En entornos donde varios microservicios dependen entre sí (facturación, usuarios, notificaciones), el disyuntor evita que un servicio lento bloquee a los demás.

**Plataformas de streaming o contenido bajo demanda:**  
Si el servicio de recomendación o catálogo falla, el disyuntor devuelve una lista temporal o en caché, manteniendo la operatividad parcial sin afectar la experiencia del usuario.

---

### Aplicación en el proyecto grupal

En el proyecto **Lyra**, dentro del **módulo de gestión de planes y suscripciones**, el patrón Disyuntor se implementará para **proteger las llamadas hacia la pasarela de pagos Stripe**.

**Flujo del proceso:**
1. El usuario premium ingresa sus datos de pago en un entorno seguro (*Stripe.js*), donde los datos son tokenizados cumpliendo el estándar **PCI-DSS**.  
2. El backend recibe el token y lo envía a Stripe a través de un método protegido por el disyuntor.  
3. Si Stripe responde correctamente, el pago se confirma y se actualiza el estado de la suscripción.  
4. Si Stripe no responde o arroja errores repetidos, el circuito se abre, evitando nuevos intentos por un tiempo definido (por ejemplo, 30 segundos).  
5. Durante ese tiempo, el sistema muestra un mensaje controlado al usuario:

> “El servicio de pagos no está disponible temporalmente. Por favor, inténtalo más tarde.”

6. Los **logs del disyuntor** registran el incidente, permitiendo un diagnóstico rápido por parte del equipo de soporte técnico.

# Consideraciones técnicas

Por completar
---

[⬅️ Anterior](../0.7.2/0.7.2.md) | [🏠 Home](../../../README.md) | [Siguiente ➡️](../0.7.4/0.7.4.md)