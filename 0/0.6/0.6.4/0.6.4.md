> [0. Acerca del Grupo](../../0.md) › [0.6. Temas Individuales (Parte 1)](../0.6.md) › [0.6.4. Integrante 4](0.6.4.md)

# 0.6.4. Ana Meza
---
# 🧠 Desarrollo Conceptual — Orquestación de Contenedores

## ✅ ¿Qué es?
La **orquestación de contenedores** es el conjunto de prácticas y componentes que automatizan el **despliegue, escalado, actualización y operación** de aplicaciones en contenedores sobre un **clúster**. Funciona de forma **declarativa**: defines el *estado deseado* (p. ej., “3 réplicas de este servicio”) y el orquestador lo mantiene mediante **reconciliación**, gestionando redes, almacenamiento, secretos, políticas y observabilidad.

### 🖇️ ¿Qué es un clúster?
Un **clúster** es un **conjunto de máquinas** (físicas o virtuales) que operan como un sistema único:
- **Plano de control**: decide y coordina (API, scheduler, controladores).
- **Nodos de trabajo** (*workers*): ejecutan los contenedores/pods.
- Comparten **red** y, cuando aplica, **almacenamiento**, habilitando **alta disponibilidad** y **escalado** al distribuir la carga y reemplazar instancias con fallas automáticamente.

---

## 🌟 ¿Por qué usar un orquestador?
- **Alta disponibilidad y autorreparación** (recrea pods si fallan).
- **Escalabilidad horizontal automática** (HPA/VPA) según carga o métricas.
- **Despliegues seguros y sin caída**: *rolling*, *blue/green*, *canary* y **rollback**.
- **Estandarización operativa** (red, volúmenes, secretos, políticas).
- **Uso eficiente de recursos** (bin-packing con *requests/limits*).
- **Observabilidad** integrada (métricas, logs, trazas) para SRE.

---

## 🟩 Cuándo conviene
- **Microservicios** o múltiples servicios que deben alinearse.
- **Picos de demanda** y necesidad de **autoscaling**.
- **Entornos multi-equipo** con cuotas, aislamiento y políticas.
- **Entrega continua** con despliegues frecuentes y *rollback* ágil.
- **Plataformas internas** (PaaS) que hospedan varios productos.

## 🟥 Cuándo *no* conviene
- Proyectos **pequeños/estáticos** (un servicio simple sin escalar).
- Equipos **sin capacidad operativa** para administrar un clúster.
- Workloads con **dependencias muy host-acopladas**.
- Requisitos de **tiempo real duro** donde la sobrecarga no es aceptable.

---

## ⚠️ Desafíos y riesgos (a gestionar)
- **Curva de aprendizaje** y complejidad operativa.
- **Costos** por sobredimensionamiento o *requests/limits* mal definidos.
- **Seguridad**: exfiltración de secretos, imágenes vulnerables, red abierta.
- **Observabilidad** insuficiente complica diagnóstico y *MTTR*.

---

## 🧩 Componentes y conceptos clave (agnósticos)
| Capa | Qué hace | Ejemplos |
|---|---|---|
| **Plano de control** | Mantiene estado deseado y programa cargas | API Server, Scheduler, Controladores |
| **Plano de datos** | Ejecuta contenedores y expone red/volúmenes | Nodos de trabajo + runtime |
| **Red (CNI)** | Conectividad y políticas L3/L4 | Calico, Cilium, Flannel |
| **Almacenamiento (CSI)** | Provisión de volúmenes y *claims* | HostPath, NFS, Ceph |
| **Identidad y acceso** | Permisos por rol | RBAC, ServiceAccounts |
| **Observabilidad** | Métricas, logs, trazas | metrics-server, Prometheus/Grafana, Loki/ELK, OpenTelemetry |

---

## 🛠️ Objetos/patrones típicos
| Objeto/Patrón | Qué resuelve | Ejemplo |
|---|---|---|
| **Deployment** | Réplicas y estrategia de actualización | 3 pods con *rolling update* 25%/25% |
| **Service** | Descubrimiento y balanceo L4 | `ClusterIP` (interno), `NodePort/LoadBalancer` (externo) |
| **Ingress / Gateway** | Enrutamiento HTTP/HTTPS L7 | Ruta `/api` → servicio `backend` con TLS |
| **ConfigMap / Secret** | Config y credenciales fuera del código | `APP_MODE=prod`, token base64 |
| **Job / CronJob** | Tareas puntuales o programadas | ETL diario 03:00 |
| **HPA / VPA** | Autoscaling por métricas o ajuste de recursos | Escalar si CPU > 70% |
| **NetworkPolicy** | Control de tráfico entre pods | Solo `frontend` → `api` |

---

## 🔁 Estrategias de despliegue
| Estrategia | Úsala cuando… | Trade-off |
|---|---|---|
| **Rolling Update** | Cambios frecuentes con bajo riesgo | Mínimo riesgo; propagación gradual |
| **Recreate** | Incompatibilidad de estado/sesiones | Downtime breve |
| **Blue/Green** | Cambios grandes; *rollback* instantáneo | Requiere doble capacidad |
| **Canary** | Validar con % pequeño de tráfico | Mayor complejidad de ruteo/telemetría |

---

## 📏 Métricas clave de operación
- **Disponibilidad (SLA/SLO)** y **error rate** por servicio.  
- **Latencias** P50/P95/P99 en endpoints críticos.  
- **CPU/RAM** usados vs *requests/limits* (evitar *throttling* y **OOMKilled**).  
- **Tiempo de despliegue** y **tasa de rollback**.  
- **MTTR** ante fallas y **saturación** (colas, conexiones, límites de pod/nodo).

---

## 📚 Glosario rápido
- **Pod**: unidad mínima de ejecución (uno o más contenedores).  
- **ReplicaSet**: mantiene el número de pods.  
- **Namespace**: segmentación lógica de recursos.  
- **CNI/CSI**: interfaces de red/almacenamiento para plugins.  
- **GitOps**: manifiestos en Git como **fuente de verdad** y reconciliación continua.

> **Nota:** Este marco es **independiente del proveedor** (Kubernetes, Nomad, Swarm). La demo del repositorio se ejecutará en un **clúster local** con manifiestos YAML estándar.

## **DEMO**



[⬅️ Anterior](../0.6.3/0.6.3.md) | [🏠 Home](../../../README.md) | [Siguiente ➡️](../0.6.5/0.6.5.md)