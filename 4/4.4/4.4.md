> [4. Decisiones Iniciales de Arquitectura](../4.md) › [4.4. Módulo Gestión de Preferencias de Usuario / Ana Meza](4.4.md)

# 4.4. Gestión de Preferencias de Usuario / Ana Meza

### Decisiones de Asignación de Responsabilidades

### Decisión 1:

**Título**
- Separación del módulo de Preferencias como microservicio independiente (Preferences Service)

**Contexto**
- Las preferencias (tema, idioma, notificaciones opt-in/out, calidad de reproducción, layouts, accesibilidad, etc.) requieren baja latencia de lectura, versionado y trazabilidad por usuario y por dispositivo.

- Mezclarlas con perfil o autenticación dificulta el escalamiento y la evolución de esquemas sin afectar dominios críticos.

**Alternativas**
- Incluir preferencias dentro de User Profile Service.

- Persistir preferencias en el cliente y sincronizarlas de forma best-effort.

**Criterios de Elección**
- Aislamiento de cambios de esquema sin impactar otros dominios.

- Escalabilidad de lecturas (read-heavy) y caché específica.

- Auditoría (historial de cambios) y reversión (rollbacks) por usuario/dispositivo.

**Decisión**
- **Crear un microservicio Preferences Service con su propio datastore y API, responsable de CRUD, versionado y auditoría de preferencias.**

**Sustento**
- Reduce el acoplamiento con Perfil y Auth, permite escalar lecturas con caché y soporta evolución rápida de claves/valores y estructuras anidadas sin riesgo al resto del sistema.

--

### Decisión 2:

**Título**
- Modelo de datos híbrido: key-value tipado + esquema normalizado para preferencias sensibles

**Contexto**
- La mayoría de preferencias son simples (key-value) y cambian con frecuencia; otras (p. ej., consentimientos de tracking por categoría) requieren integridad, referencialidad y cumplimiento normativo.

**Alternativas**
- Todo key-value en documento.

- Todo relacional normalizado.

- Enfoque híbrido: documento key-value tipado para ajustes generales + tablas normalizadas para ámbitos regulados.

**Criterios de Elección**
- Flexibilidad para nuevas claves sin migraciones costosas.
- Garantías de integridad y auditoría para preferencias reguladas.
- Rendimiento en lecturas masivas y filtros por ámbito.

**Decisión**
- **Usar almacenamiento documental (p. ej., JSON) para claves generales con tipado y validación de esquema; y tablas relacionales para consentimientos y flags sujetos a normativa.**

**Sustento**
- Permite velocidad de cambio donde importa (UI/UX) y control estricto donde se exige (privacidad, auditoría).

---

### Decisión 3:

**Título**
- Jerarquía y reglas de resolución de preferencias (global, app, tenant, usuario, dispositivo)

**Contexto**
- Un usuario puede tener múltiples dispositivos y pertenecer a distintos tenants/espacios. Las preferencias se aplican por ámbito y deben resolverse determinísticamente.

**Alternativas**
- Solo nivel usuario.
- Solo nivel dispositivo.
- Jerarquía con herencia y precedencia configurables.

**Criterios de Elección**
- Experiencia consistente entre dispositivos con posibilidad de overrides locales.
- Simplicidad para el cliente (SDK) y trazabilidad del valor efectivo.
- Idempotencia y reproducibilidad ante auditoría.

**Decisión**
- **Definir jerarquía de resolución: default global → app → tenant/espacio → usuario → dispositivo. El valor efectivo y su fuente se devuelven en cada respuesta.**

**Sustento**
- Evita ambigüedades, facilita depuración y permite políticas corporativas por tenant sin bloquear preferencias personales.

---

### Decisiones de Modelo de Datos
### Decisión 1:
**Título**
- Modelo híbrido para preferencias: Key-Value tipado + entidades normalizadas para ámbitos regulados

**Contexto**
- La mayoría de preferencias son configuraciones simples (tema, idioma, accesibilidad, layouts) que cambian con alta frecuencia.

**Alternativas**
- Todo en tabla relacional normalizada.
- Todo en documento/NoSQL (KV sin esquema).
- Enfoque híbrido con JSONB para claves genéricas y tablas relacionales para ámbitos regulados.

**Criterios de Elección**
- Flexibilidad de esquema y evolución sin migraciones costosas.
- Integridad y auditoría donde lo exige la normativa.
- Performance en lecturas masivas con filtros por usuario/ámbito.

**Decisión**
- **Usar user_preferences (JSONB con tipado/validación de esquema) para claves generales y regulated_preferences (relacional) para consentimientos/flags sujetos a cumplimiento**

**Sustento**
- Permite velocidad de cambio en UI/UX, manteniendo control estricto y trazable en datos sensibles.

### Decisión 2:
**Título**
- Esquema de resolución jerárquica y llave compuesta para escopos

**Contexto**
- Las preferencias se aplican por jerarquía: global → app → tenant → usuario → dispositivo.
- Se necesita determinismo e inspección del “valor efectivo” y su fuente.

**Alternativas**
- Resolver solo a nivel usuario.
- Duplicar valores por cada ámbito.
- Modelo con overrides por ámbito y resolución determinística.

**Criterios de Elección**
- Simplicidad para el cliente y reproducibilidad.
- Consultas rápidas por usuario/ámbito/clave.
- Evitar ambigüedades y condiciones de carrera.

**Decisión**
- **Definir llave compuesta (user_id, scope_type, scope_id, pref_key) con columna effective_value calculada en lectura y source_scope retornado en API.**

**Sustento**
- Facilita depuración, reduce duplicidad y garantiza consistencia entre dispositivos/tenants.

---

### Decisiones de Elección de Tecnología
### Decisión 1:
**Título**
- Backend con NestJS (Node.js + TypeScript) y validación de esquema

**Contexto**
- El servicio es read-heavy, requiere validaciones consistentes y contratos claros entre clientes.
- Se busca modularidad, inyección de dependencias y pipes de validación.

**Alternativas**
- Express “bare”.
- Spring Boot (Java).
- NestJS con class-validator/zod para DTOs.

**Criterios de Elección**
- Productividad y patrón de módulos.
- Pruebas unitarias/e2e integradas.
- ETipado fuerte y DX consistente.

**Decisión**
- **Adoptar NestJS + TypeScript con DTOs validados (Zod o class-validator) y OpenAPI autogenerado.**

**Sustento**
- Acelera el desarrollo, estandariza controladores/guards y facilita contratos API bien definidos.

### Decisión 2:
**Título**
- PostgreSQL como datastore principal con JSONB + índices GIN

**Contexto**
- Se requieren relaciones (usuarios, tenants), transacciones y campos flexibles para preferencias.

**Alternativas**
- MongoDB (documental puro).
- MySQL
- PostgreSQL con JSONB.

**Criterios de Elección**
- ACID, integridad referencial y JSONB nativo.
- Índices eficientes (BTREE/GIN compuestos).
- Operadores JSON y consultas mixtas.

**Decisión**
- **Usar PostgreSQL; user_preferences con JSONB e índice GIN por pref_key y filtros por (user_id, scope); entidades reguladas relacionales.**

**Sustento**
- Combina consistencia y flexibilidad, optimizando las consultas frecuentes del módulo.

### Decisión 3:
**Título**
- Redis para caché + Pub/Sub de invalidación; bus de eventos para propagación

**Contexto**
- La UI lee preferencias en cada carga; cambios deben reflejarse casi en tiempo real.
- Otros servicios (Notificaciones, Recomendador) dependen de señales de preferencias

**Alternativas**
- Solo DB sin caché
- Caché cliente únicamente
- Caché servidor + invalidación por eventos y outbox pattern

**Criterios de Elección**
- Latencia P95 baja.
- Consistencia eventual controlada.
- Desacoplamiento entre productores/consumidores.

**Decisión**
- **Caché Redis (TTL corto) con invalidación por canal Pub/Sub; emisión de preference.changed al bus (Kafka/NATS) usando Transactional Outbox.**

**Sustento**
- Reduce latencia de lectura y asegura propagación fiable sin acoplar servicios.
---

### Decisiones de Tiempo de Enlace
### Decisión 1:
**Título**  
- Catálogo de claves y reglas de resolución cargado en build con hot reload opcional

**Contexto**  
- Las claves de preferencias y sus metadatos (tipo, default, rango, validadores) conforman un catálogo.  
- Se requieren cambios operativos sin forzar redeploy completo, manteniendo trazabilidad por versión.

**Alternativas**  
- Catálogo hard-coded en el binario.  
- Carga únicamente en tiempo de ejecución desde un servicio de configuración.  
- Enfoque mixto: snapshot en build + recarga controlada en runtime.

**Criterios de Elección**  
- Estabilidad y reproducibilidad por versión.  
- Flexibilidad para ajustes operativos.  
- Auditoría de cambios y rollbacks simples.

**Decisión**  
- **Empaquetar un snapshot del catálogo en la imagen (build) y habilitar recarga en runtime desde Config Service/Blob firmado, activable por feature flag.**

**Sustento**  
- Garantiza consistencia entre entornos y permite ajustes sin reconstruir la imagen cuando sea necesario.  
---

### Decisión 2:
**Título**  
- Enlace dinámico de integraciones opcionales mediante variables de entorno/gestor de secretos

**Contexto**  
- Integraciones (p. ej., recomendador, marketing) consumen señales de preferencias pero no están presentes en todos los entornos.  
- Credenciales y endpoints cambian y no deben versionarse en código.

**Alternativas**  
- Compilar variantes por entorno.  
- Enlazar todas las integraciones siempre.  
- Cargar conectores a demanda en tiempo de ejecución.

**Criterios de Elección**  
- Seguridad de secretos.  
- Flexibilidad y zero-downtime.  
- Menor huella en dev/test.

**Decisión**  
- **Resolver endpoints/credenciales vía variables de entorno o Vault; inicializar conectores solo si `INTEGRATION_* = enabled`.**

**Sustento**  
- Evita builds por entorno, reduce costos y riesgos al no cargar componentes innecesarios.  
---

### Decisión 3:
**Título**  
- Enlace diferido para consumidores de eventos (Analytics/ML) y guards de degradación

**Contexto**  
- La operación base de preferencias no debe depender del bus/eventos.  
- La publicación de eventos no puede bloquear escrituras.

**Alternativas**  
- Publicar sincrónicamente y fallar si el bus no responde.  
- Colas internas con reintentos y dead-letter.  
- Ejecutar todo sincrónico sin fallbacks.

**Criterios de Elección**  
- Resiliencia ante fallas externas.  
- Garantía de entrega al menos una vez.  
- Impacto mínimo en la latencia de escritura.

**Decisión**  
- **Usar Transactional Outbox + worker asíncrono con reintentos y DLQ; circuit breaker para degradar a “solo DB + caché” si el bus falla.**

**Sustento**  
- Aísla el CRUD crítico de dependencias no esenciales y mantiene SLAs aun con caídas del pipeline de eventos.  

---

[⬅️ Anterior](../4.3/4.3.md) | [🏠 Home](../../README.md) | [Siguiente ➡️](../4.5/4.5.md)