> [4. Decisiones Iniciales de Arquitectura](../4.md) › [4.2. Módulo Autenticación y Usuarios / Pedro Morales](4.2.md)

# Autenticación y Usuarios / Pedro Morales

## Decisiones de Asignación de Responsabilidades  

### Decisión 1:

**Título**  
- Separación del servicio de autenticación como módulo independiente

**Contexto**  
- El sistema requiere garantizar seguridad, escalabilidad y trazabilidad en los procesos de registro, inicio de sesión, recuperación de cuenta y gestión de sesiones.  
- Se identificó la necesidad de desacoplar la autenticación del resto de la lógica de negocio (generación de playlists, preferencias, etc.) para aislar posibles vulnerabilidades.  

**Alternativas**  
- Integrar la autenticación dentro del backend general.  
- Usar un servicio externo de autenticación (Auth0, Firebase Auth).  
- Implementar un microservicio interno especializado en autenticación.  

**Criterios de Elección**  
- Control total sobre políticas de seguridad y almacenamiento de usuarios.  
- Escalabilidad independiente del core funcional.  
- Capacidad de auditoría y personalización de tokens.  

**Decisión**  
- **Implementar un microservicio interno de autenticación (Auth Service) encargado exclusivamente del registro, login, emisión y revocación de tokens.**  

**Sustento**  
- Permite mantener la seguridad como dominio aislado con control granular de sesiones y auditoría.  
- Facilita la futura integración con proveedores externos mediante OAuth 2.0 sin alterar la lógica principal del sistema.  

---

### Decisión 2:

**Título**  
- Asignación de responsabilidades entre los servicios de Usuario, Privacidad y Notificaciones  

**Contexto**  
- La aplicación gestiona múltiples aspectos del usuario: autenticación, perfil, línea de tiempo, consentimiento y comunicación.  
- Centralizar todas estas responsabilidades en un solo módulo afectaría la mantenibilidad y la velocidad de respuesta del sistema.  

**Alternativas**  
- Mantener toda la gestión de usuarios en un único módulo monolítico.  
- Dividir las funciones en submódulos especializados: Auth Service, User Profile Service, Privacy Service y Notification Service.  

**Criterios de Elección**  
- Separación clara de dominios (Single Responsibility Principle).  
- Sincronización controlada entre servicios.  
- Independencia para despliegues y pruebas por módulo.  

**Decisión**  
- **Dividir la responsabilidad del módulo en cuatro subcomponentes: Auth Service (autenticación), User Profile (perfil e historial), Privacy Service (consentimientos) y Notification Service (comunicación).**  

**Sustento**  
- Mejora la trazabilidad y el mantenimiento al permitir que cada servicio evolucione de forma independiente.  
- Facilita la identificación y resolución de fallas en un componente específico sin afectar los demás.  

---

### Decisión 3:

**Título**  
- Responsabilidad compartida en seguridad y control de acceso entre Auth Service y API Gateway  

**Contexto**  
- El sistema requiere un nivel alto de protección frente a intentos de fuerza bruta, sesiones múltiples y accesos no autorizados.  
- Los endpoints deben ser protegidos tanto a nivel de token (lógica de negocio) como a nivel de tráfico de red.  

**Alternativas**  
- Delegar toda la seguridad al backend.  
- Utilizar un firewall externo sin validación de tokens.  
- Implementar una responsabilidad compartida entre Auth Service (validación de tokens) y API Gateway (filtrado y rate limiting).  

**Criterios de Elección**  
- Reducción de carga en el backend por validaciones redundantes.  
- Mayor defensa en profundidad (“defense in depth”).  
- Monitoreo centralizado del tráfico y detección temprana de anomalías.  

**Decisión**  
- **Establecer una capa doble de seguridad: el API Gateway maneja el rate limiting y WAF, mientras que el Auth Service valida tokens y gestiona el control de sesiones.**  

**Sustento**  
- Se garantiza un control integral de acceso y detección temprana de amenazas sin comprometer el rendimiento.  
- Facilita la trazabilidad de eventos de seguridad al centralizar logs y auditorías en el Gateway y el Auth Service.  

---
---

## Decisiones de Modelo de Datos

### Decisión 1:

**Título**  
- Diseño del modelo de usuario con enfoque en seguridad y extensibilidad  

**Contexto**  
- El módulo requiere almacenar información de usuario que incluya credenciales, perfil y preferencias, sin comprometer la seguridad.  
- Además, se busca permitir futuras integraciones con servicios externos como Spotify o Google mediante OAuth.  

**Alternativas**  
- Modelo de usuario monolítico con todos los campos en una sola tabla.  
- Separar credenciales y datos de perfil en diferentes entidades.  
- Usar un esquema NoSQL para mayor flexibilidad en atributos.  

**Criterios de Elección**  
- Seguridad en el almacenamiento de credenciales.  
- Escalabilidad y fácil mantenimiento.  
- Compatibilidad con relaciones y auditorías.  

**Decisión**  
- **Separar los datos en entidades lógicas: `users` (credenciales básicas), `user_profile` (datos personales) y `user_settings` (preferencias y visibilidad).**  

**Sustento**  
- Permite mantener las credenciales aisladas del resto de la información del usuario, reduciendo el riesgo en caso de brecha.  
- Facilita la extensión del perfil con nuevos atributos sin alterar la estructura principal.  

---

### Decisión 2:

**Título**  
- Implementación de almacenamiento seguro y cifrado de datos sensibles  

**Contexto**  
- El sistema maneja contraseñas, correos y tokens que deben cumplir con estándares de seguridad y privacidad (GDPR, OWASP).  
- Se necesita asegurar la trazabilidad y proteger la información frente a ataques o accesos no autorizados.  

**Alternativas**  
- Almacenar contraseñas y correos en texto plano (no viable).  
- Usar hash estándar (MD5/SHA1).  
- Aplicar hashing con bcrypt y cifrado AES-256 para datos sensibles.  

**Criterios de Elección**  
- Cumplimiento de buenas prácticas OWASP.  
- Capacidad de auditar accesos y fallos de seguridad.  
- Bajo impacto en rendimiento de consultas.  

**Decisión**  
- **Usar hash bcrypt + salt para contraseñas y cifrado AES-256 para correos, tokens y datos sensibles.**  

**Sustento**  
- Garantiza protección en reposo y evita la reversión de contraseñas.  
- Cumple estándares de seguridad modernos sin afectar la velocidad de lectura.  

---

### Decisión 3:

**Título**  
- Estructura de almacenamiento para sesiones, consentimientos y auditorías  

**Contexto**  
- El sistema requiere registrar sesiones activas, consentimientos informados y eventos de auditoría por usuario.  
- Estos datos deben mantenerse separados para escalar y permitir auditorías legales o de soporte.  

**Alternativas**  
- Unificar todo en una sola tabla de “actividad de usuario”.  
- Crear tablas independientes para cada tipo de registro.  
- Utilizar una base NoSQL para eventos.  

**Criterios de Elección**  
- Mantenibilidad y trazabilidad de acciones.  
- Consultas rápidas y segmentadas por tipo de evento.  
- Posibilidad de auditorías históricas.  

**Decisión**  
- **Crear tres entidades separadas: `session_tokens` (gestión de sesiones activas), `consent_logs` (versionado de consentimientos) y `audit_logs` (registro inmutable de eventos).**  

**Sustento**  
- Facilita la depuración y auditoría al mantener un histórico completo de cambios.  
- Permite escalar cada componente (sesiones, consentimientos, auditoría) de forma independiente según la carga o necesidad legal.  

--- 
---

## Decisiones de Elección de Tecnología

### Decisión 1:

**Título**  
- Selección de Node.js con Express como framework backend para autenticación  

**Contexto**  
- El módulo requiere manejar múltiples flujos de autenticación (registro, login, OAuth, recuperación de cuenta) con alta concurrencia y baja latencia.  
- Se busca una tecnología con ecosistema maduro, soporte de bibliotecas de seguridad (JWT, OAuth 2.0) y facilidad para integrarse con microservicios.  

**Alternativas**  
- Python (Django/Flask)  
- Java (Spring Boot)  
- Node.js (Express/NestJS)  

**Criterios de Elección**  
- Rendimiento en entornos de I/O intensivo.  
- Ecosistema de librerías modernas para seguridad y autenticación.  
- Curva de aprendizaje baja y comunidad activa.  

**Decisión**  
- **Adoptar Node.js con Express para el desarrollo del microservicio de autenticación.**  

**Sustento**  
- Permite manejar peticiones concurrentes con bajo consumo de recursos.  
- Facilita la integración con servicios OAuth y APIs REST ya existentes en el sistema.  

---

### Decisión 2:

**Título**  
- Selección de PostgreSQL como base de datos principal del módulo de usuarios  

**Contexto**  
- El módulo necesita almacenar información estructurada (usuarios, sesiones, consentimientos) y datos semiestructurados (preferencias, historial) con consistencia y seguridad.  
- Es esencial mantener integridad referencial y soporte de auditoría con logs inmutables.  

**Alternativas**  
- MySQL  
- MongoDB  
- PostgreSQL  

**Criterios de Elección**  
- Soporte de JSONB para campos flexibles.  
- Integridad referencial y transaccionalidad ACID.  
- Seguridad avanzada y roles granulares.  

**Decisión**  
- **Usar PostgreSQL como base de datos principal, aprovechando su estructura relacional y soporte JSONB para datos de usuario.**  

**Sustento**  
- Permite modelar relaciones complejas entre usuarios, sesiones y consentimientos.  
- Combina la seguridad y consistencia de una base SQL con flexibilidad semiestructurada.  

---

### Decisión 3:

**Título**  
- Integración de servicios externos: OAuth, mensajería y monitoreo  

**Contexto**  
- El módulo debe conectarse a servicios externos para inicio de sesión social (Spotify, Google, Apple), envío de correos de verificación y notificaciones push.  
- Se busca garantizar confiabilidad, entrega oportuna y trazabilidad.  

**Alternativas**  
- Desarrollar soluciones internas de correo y push.  
- Usar servicios administrados externos.  

**Criterios de Elección**  
- Confiabilidad del proveedor y SLA garantizado.  
- Facilidad de integración mediante SDKs o APIs REST.  
- Coste y escalabilidad del servicio.  

**Decisión**  
- **Integrar servicios externos especializados: OAuth 2.0 para autenticación social, SendGrid para correos y Firebase Cloud Messaging (FCM) para notificaciones push.**  

**Sustento**  
- Reduce la complejidad de mantenimiento y mejora la entrega de mensajes críticos (verificación, 2FA).  
- Garantiza la compatibilidad con los principales ecosistemas móviles y web, manteniendo trazabilidad mediante logs y paneles de monitoreo.  

---
---

## Decisiones de Tiempo de Enlace

### Decisión 1:

**Título**  
- Configuración de dependencias y librerías de autenticación en tiempo de compilación  

**Contexto**  
- El servicio de autenticación depende de librerías externas (JWT, bcrypt, OAuth, nodemailer, etc.) que deben estar estandarizadas para todos los entornos de despliegue.  
- Es necesario garantizar que todas las dependencias críticas se resuelvan durante el proceso de build para evitar errores en producción.  

**Alternativas**  
- Resolver dependencias en tiempo de ejecución.  
- Resolver dependencias en tiempo de compilación con control de versiones.  
- Usar contenedores con dependencias preinstaladas.  

**Criterios de Elección**  
- Consistencia entre entornos (dev, staging, prod).  
- Evitar fallos por versiones incompatibles.  
- Facilitar despliegues automatizados (CI/CD).  

**Decisión**  
- **Resolver las dependencias críticas en tiempo de compilación mediante archivo `package-lock.json` y validaciones en el pipeline CI/CD.**  

**Sustento**  
- Garantiza estabilidad y reproducibilidad del entorno de ejecución.  
- Permite detectar conflictos de librerías antes del despliegue.  

---

### Decisión 2:

**Título**  
- Enlace dinámico de servicios externos (OAuth, SendGrid, Firebase) mediante variables de entorno  

**Contexto**  
- El sistema se conecta a servicios externos cuyos tokens y credenciales cambian con frecuencia y no deben estar embebidos en el código fuente.  
- Se necesita flexibilidad para modificar configuraciones sin recompilar el sistema.  

**Alternativas**  
- Definir credenciales estáticamente en el código.  
- Usar variables de entorno en tiempo de ejecución.  
- Configurar un gestor de secretos centralizado (Vault).  

**Criterios de Elección**  
- Seguridad de las credenciales.  
- Facilidad de actualización sin downtime.  
- Compatibilidad con el pipeline de despliegue.  

**Decisión**  
- **Implementar un enlace dinámico a servicios externos usando variables de entorno (`.env`) inyectadas en tiempo de ejecución por el orquestador (Docker/CI).**  

**Sustento**  
- Permite cambiar credenciales y endpoints sin recompilar el servicio.  
- Refuerza la seguridad al evitar exponer secretos en el código fuente.  

---

### Decisión 3:

**Título**  
- Enlace diferido para módulos opcionales (notificaciones y auditoría)  

**Contexto**  
- Algunos módulos, como notificaciones push y registros de auditoría, no son críticos para la autenticación base y pueden activarse o desactivarse según el entorno.  
- Se busca mantener bajo consumo de recursos en entornos de desarrollo o pruebas unitarias.  

**Alternativas**  
- Enlazar todos los módulos durante la compilación.  
- Enlazar módulos opcionales dinámicamente en tiempo de ejecución.  
- Mantener microservicios separados siempre activos.  

**Criterios de Elección**  
- Optimización de recursos.  
- Flexibilidad para pruebas.  
- Independencia funcional del core de autenticación.  

**Decisión**  
- **Utilizar enlace diferido en tiempo de ejecución para módulos opcionales, cargándolos únicamente cuando las variables de entorno los habiliten.**  

**Sustento**  
- Mejora la eficiencia y reduce el uso de memoria en entornos de desarrollo.  
- Permite habilitar funcionalidades avanzadas (como auditoría o notificaciones) sin modificar el core ni requerir un nuevo build.  

---
---

[⬅️ Anterior](../4.1/4.1.md) | [🏠 Home](../../README.md) | [Siguiente ➡️](../4.3/4.3.md)