> [4. Decisiones Iniciales de Arquitectura](../4.md) › [4.5. Módulo Integración con Plataformas Externas / Andrew Tamayo](4.5.md)

# 4.5. Integración con Plataformas Externas / Andrew Tamayo

### Decisiones de Asignación de Responsabilidades

### Decisión 1:

**Título**
- Implementación de una capa de abstracción vendor-agnostic para integraciones con plataformas de música

**Contexto**
- LYRA debe integrarse inicialmente con Spotify pero debe estar preparado para integrar Apple Music y YouTube Music en el futuro.
- Cada plataforma tiene APIs diferentes con distintos modelos de datos, métodos de autenticación y limitaciones de tasa.
- Se requiere mantener la consistencia funcional independientemente del proveedor de música seleccionado por el usuario.

**Alternativas**
- Implementar cada integración de forma independiente y específica para cada proveedor.
- Crear una interfaz común que abstraiga las diferencias entre proveedores mediante adaptadores.
- Usar bibliotecas de terceros que unifiquen las integraciones.

**Criterios de Elección**
- Extensibilidad: facilitar la incorporación de nuevos proveedores sin modificar el core del sistema.
- Mantenibilidad: minimizar la duplicación de código y lógica de negocio.
- Consistencia: garantizar experiencia uniforme independientemente del proveedor.
- Testabilidad: permitir pruebas de contrato que validen compatibilidad futura.

**Decisión**
- **Se implementará una capa de abstracción con interfaz común (MusicProviderInterface) y adaptadores específicos por proveedor (SpotifyAdapter, AppleMusicAdapter, etc.).**

**Sustento**
- Permite evolucionar y agregar nuevos proveedores sin impacto en la lógica de negocio principal.
- Facilita el testing mediante mocks y contratos que validan la compatibilidad entre adaptadores.
- Mantiene la flexibilidad para optimizar cada integración según las particularidades de cada API externa.

---

### Decisión 2:

**Título**
- Separación de responsabilidades entre autenticación OAuth, gestión de tokens y operaciones de playlists

**Contexto**
- Las integraciones requieren manejar flujos OAuth complejos, refresh de tokens, manejo de expiración y operaciones CRUD sobre playlists.
- La autenticación OAuth tiene ciclos de vida diferentes a las operaciones de playlists y requiere manejo especializado de seguridad.
- Los tokens de acceso deben ser renovados automáticamente sin interrumpir las operaciones del usuario.

**Alternativas**
- Manejar toda la lógica de OAuth y operaciones de playlist en un solo servicio.
- Separar en servicios especializados: OAuth Service, Token Manager y Playlist Operations Service.
- Delegar completamente la autenticación a un proveedor externo (Auth0, Firebase).

**Criterios de Elección**
- Seguridad: aislamiento de credenciales y tokens sensibles.
- Escalabilidad: permitir optimización independiente de cada responsabilidad.
- Mantenibilidad: facilitar debugging y actualizaciones sin afectar otros componentes.
- Disponibilidad: evitar que fallos en autenticación afecten operaciones ya autenticadas.

**Decisión**
- **Dividir las responsabilidades en tres componentes: OAuth Service (manejo de flujos de autorización), Token Manager (gestión y renovación de tokens) y Platform Operations Service (operaciones sobre playlists y contenido).**

**Sustento**
- Mejora la seguridad al aislar el manejo de tokens en un componente especializado con políticas de cifrado específicas.
- Permite escalar cada componente según su carga (las operaciones de playlist son más frecuentes que los flujos OAuth).
- Facilita el mantenimiento y la resolución de problemas al tener responsabilidades claramente separadas.

---

### Decisión 3:

**Título**
- Implementación de sistema de cola y retry con backoff exponencial para manejo de rate limits

**Contexto**
- Las APIs externas (especialmente Spotify) tienen límites estrictos de tasa (rate limits) que varían según el endpoint y el tipo de operación.
- Los fallos temporales (HTTP 429, 5xx) requieren estrategias de reintento inteligentes para no saturar los servicios externos.
- Se debe mantener la experiencia del usuario fluida even cuando se alcancen los límites de tasa.

**Alternativas**
- Realizar llamadas directas sin manejo de rate limits, dejando que falle cuando se alcancen.
- Implementar un sistema de cola simple con reintentos fijos.
- Crear un sistema robusto de cola con backoff exponencial, jitter y circuit breaker.

**Criterios de Elección**
- Confiabilidad: garantizar que las operaciones eventualmente se completen.
- Experiencia de usuario: minimizar interrupciones y proporcionar feedback apropiado.
- Respeto a servicios externos: evitar saturar las APIs con reintentos agresivos.
- Observabilidad: permitir monitoreo y alertas sobre patrones de fallos.

**Decisión**
- **Implementar un sistema de cola con backoff exponencial (base 2, max 60s), jitter aleatorio y circuit breaker con límite de 3 reintentos por operación.**

**Sustento**
- Mejora la confiabilidad al manejar inteligentemente los fallos temporales y rate limits.
- Protege los servicios externos al implementar patrones de reintento respetuosos con intervalos crecientes.
- Proporciona feedback claro al usuario sobre el estado de las operaciones y sugiere acciones cuando se agotan los reintentos.

---

### Decisiones de Modelo de Datos

### Decisión 1:

**Título**
- Diseño de modelo de datos para tokens OAuth con soporte multi-proveedor y rotación automática

**Contexto**
- El sistema debe almacenar tokens de acceso, refresh tokens y metadatos de múltiples proveedores de música por usuario.
- Los tokens tienen diferentes ciclos de vida y deben renovarse automáticamente sin intervención del usuario.
- Se requiere mantener histórico para auditoría y rollback en caso de problemas.

**Alternativas**
- Almacenar tokens en una tabla única con campos genéricos.
- Crear tablas específicas por proveedor (spotify_tokens, apple_tokens, etc.).
- Usar un modelo híbrido con tabla principal y metadatos específicos por proveedor.

**Criterios de Elección**
- Seguridad: cifrado de tokens sensibles y separación de datos críticos.
- Flexibilidad: soporte para diferentes tipos de tokens y metadatos por proveedor.
- Auditabilidad: mantener histórico de rotaciones y eventos de seguridad.
- Escalabilidad: optimización de consultas frecuentes de validación de tokens.

**Decisión**
- **Implementar una tabla principal `user_platform_tokens` con campos comunes y una tabla de metadatos `token_metadata` para información específica de cada proveedor, utilizando cifrado AES-256 para tokens sensibles.**

**Sustento**
- Permite manejar diferencias entre proveedores sin comprometer la estructura base del sistema.
- Garantiza seguridad mediante cifrado de tokens y separación de metadatos sensibles.
- Facilita consultas eficientes al tener índices optimizados sobre user_id y provider_type.

---

### Decisión 2:

**Título**
- Estructura de almacenamiento para sincronización de playlists y tracking de cambios

**Contexto**
- LYRA debe mantener sincronización bidireccional entre playlists locales y remotas (Spotify, etc.).
- Se requiere detectar cambios realizados tanto en LYRA como en la plataforma externa para resolver conflictos.
- El sistema debe manejar operaciones offline y sincronizar cuando se restaure la conexión.

**Alternativas**
- Mantener solo referencia al ID de playlist externa sin sincronización.
- Crear un sistema de versionado completo con snapshots de playlist.
- Implementar tracking de cambios incremental con timestamps y checksums.

**Criterios de Elección**
- Consistencia: garantizar que los cambios se reflejen correctamente en ambas plataformas.
- Eficiencia: minimizar transferencia de datos y operaciones innecesarias.
- Resolución de conflictos: detectar y manejar cambios simultáneos en ambas plataformas.
- Recuperación: permitir rollback y recuperación ante fallos de sincronización.

**Decisión**
- **Implementar entidades `playlist_sync_state` (estado actual), `playlist_changes_log` (log de cambios incrementales) y `sync_conflicts` (resolución de conflictos) con checksums MD5 para detección de cambios.**

**Sustento**
- Permite sincronización eficiente al transferir solo cambios incrementales detectados por checksums.
- Mantiene histórico completo para auditoría y resolución de conflictos mediante estrategias configurables.
- Soporta operaciones offline al encolar cambios para sincronización posterior.

---

### Decisión 3:

**Título**
- Modelo de datos para cache de metadatos musicales y optimización de recomendaciones

**Contexto**
- Las operaciones de recomendación requieren acceso frecuente a features musicales (valence, energy, tempo, etc.) de las canciones.
- Las APIs externas tienen latencia variable y límites de tasa que afectan la experiencia de usuario.
- Se necesita balancear frescura de datos con rendimiento y costos de API calls.

**Alternativas**
- No implementar cache y consultar siempre APIs externas.
- Cache completo en memoria con invalidación periódica.
- Cache híbrido con persistencia en BD y políticas de TTL por tipo de dato.

**Criterios de Elección**
- Rendimiento: reducir latencia en operaciones frecuentes de recomendación.
- Frescura: mantener datos actualizados sin impactar excesivamente las APIs externas.
- Escalabilidad: soportar crecimiento del catálogo sin degradar el rendimiento.
- Costo: optimizar el uso de llamadas a APIs externas que pueden tener costos asociados.

**Decisión**
- **Implementar cache persistente con entidades `cached_track_features` (TTL 7 días), `artist_metadata` (TTL 30 días) y `recommendation_seeds` (TTL 24 horas) con políticas de invalidación diferenciadas.**

**Sustento**
- Mejora significativamente el rendimiento al evitar llamadas redundantes a APIs externas durante la generación de recomendaciones.
- Optimiza costos al reducir el consumo de quotas de APIs externas mediante policies de TTL apropiadas por tipo de dato.
- Mantiene balance entre frescura y rendimiento con diferentes políticas de expiración según la volatilidad de cada tipo de metadato.

---

### Decisiones de Elección de Tecnología

### Decisión 1:

**Título**
- Selección de Node.js con framework Express para el desarrollo del módulo de integración

**Contexto**
- El módulo debe manejar múltiples integraciones HTTP concurrentes con APIs externas de música.
- Se requiere un ecosistema maduro para OAuth 2.0, manejo de tokens JWT y operaciones asíncronas intensivas.
- La integración debe ser eficiente en I/O para manejar rate limits y latencia de APIs externas sin bloquear otras operaciones.

**Alternativas**
- Python con Django/FastAPI
- Java con Spring Boot
- Node.js con Express/NestJS

**Criterios de Elección**
- Rendimiento en I/O: manejo eficiente de múltiples conexiones HTTP concurrentes.
- Ecosistema: disponibilidad de librerías maduras para OAuth, JWT y APIs de música.
- Asincronía nativa: soporte natural para operaciones no bloqueantes y manejo de colas.
- Integración: compatibilidad con el resto del stack tecnológico de LYRA.

**Decisión**
- **Adoptar Node.js con Express como runtime y framework principal, complementado con bibliotecas especializadas (passport-oauth2, ioredis, bull).**

**Sustento**
- Maximiza el rendimiento en operaciones I/O intensivas típicas de integraciones con APIs externas.
- Proporciona un ecosistema robusto con bibliotecas probadas para OAuth 2.0 y manejo de tokens.
- Facilita la implementación de sistemas de cola y retry mediante event loop no bloqueante.

---

### Decisión 2:

**Título**
- Implementación de Redis como sistema de cola y cache distribuido

**Contexto**
- El módulo requiere un sistema de cola confiable para manejar operaciones con rate limits y reintentos.
- Se necesita cache de alta velocidad para metadatos musicales y tokens de acceso frecuentemente utilizados.
- La solución debe soportar múltiples instancias del servicio para escalabilidad horizontal.

**Alternativas**
- Base de datos relacional (PostgreSQL) como cola y cache.
- Soluciones managed (AWS SQS + ElastiCache).
- Redis como solución unificada para cola, cache y pub/sub.

**Criterios de Elección**
- Rendimiento: latencia ultra-baja para cache y procesamiento eficiente de colas.
- Confiabilidad: persistencia de datos críticos y recuperación ante fallos.
- Escalabilidad: soporte para clustering y distribución horizontal.
- Simplicidad operacional: reducir complejidad de infraestructura.

**Decisión**
- **Utilizar Redis con persistencia RDB+AOF como sistema unificado de cola (Bull Queue), cache (con TTL) y pub/sub para notificaciones entre servicios.**

**Sustento**
- Proporciona rendimiento óptimo para cache con latencia submilisegundo en operaciones frecuentes.
- Garantiza confiabilidad mediante persistencia dual y soporte nativo para operaciones atómicas en colas.
- Simplifica la infraestructura al unificar múltiples necesidades en una sola tecnología probada.

---

### Decisión 3:

**Título**
- Integración de bibliotecas especializadas para cada proveedor de música y OAuth

**Contexto**
- Cada proveedor de música tiene particularidades en sus APIs que requieren manejo especializado.
- Los flujos OAuth varían entre proveedores y tienen diferentes scopes y endpoints.
- Se necesita balancear el uso de bibliotecas especializadas vs implementación propia para mantener control y flexibilidad.

**Alternativas**
- Implementar todas las integraciones desde cero usando solo HTTP clients básicos.
- Usar SDKs oficiales cuando estén disponibles y bibliotecas de terceros para otros casos.
- Crear wrappers personalizados sobre bibliotecas base manteniendo control total.

**Criterios de Elección**
- Mantenibilidad: aprovechar bibliotecas mantenidas por la comunidad o proveedores oficiales.
- Control: mantener flexibilidad para customizaciones específicas de LYRA.
- Seguridad: usar implementaciones probadas de OAuth y manejo de tokens.
- Actualizaciones: facilitar adopción de nuevas funcionalidades de APIs externas.

**Decisión**
- **Utilizar SDK oficial de Spotify (spotify-web-api-node), bibliotecas OAuth especializadas (passport-spotify, passport-oauth2) y wrappers personalizados que extiendan funcionalidad según necesidades específicas de LYRA.**

**Sustento**
- Acelera el desarrollo al aprovechar implementaciones probadas y mantenidas por especialistas.
- Mantiene flexibilidad mediante wrappers personalizados que extienden funcionalidad sin perder compatibilidad.
- Garantiza seguridad al usar bibliotecas auditadas por la comunidad para aspectos críticos como OAuth.

---

### Decisiones de Tiempo de Enlace

### Decisión 1:

**Título**
- Configuración dinámica de credenciales OAuth y endpoints mediante variables de entorno

**Contexto**
- Las credenciales de aplicaciones OAuth (client_id, client_secret) y endpoints de proveedores pueden cambiar según el entorno (desarrollo, staging, producción).
- Los proveedores pueden actualizar versiones de API o cambiar URLs base sin previo aviso.
- Se requiere flexibilidad para habilitar/deshabilitar proveedores según disponibilidad o mantenimiento.

**Alternativas**
- Hardcodear credenciales y endpoints en código fuente.
- Usar archivos de configuración estáticos por entorno.
- Implementar configuración dinámica con variables de entorno y validación en runtime.

**Criterios de Elección**
- Seguridad: evitar exposición de credenciales sensibles en repositorios de código.
- Flexibilidad: permitir cambios de configuración sin recompilación ni redespliegue.
- Validación: detectar configuraciones incorrectas en tiempo de inicio.
- Auditabilidad: registrar cambios de configuración para troubleshooting.

**Decisión**
- **Implementar configuración dinámica mediante variables de entorno con validación obligatoria al inicio del servicio y recarga sin downtime usando SIGHUP.**

**Sustento**
- Maximiza la seguridad al mantener credenciales fuera del código y permitir rotación sin redespliegue.
- Proporciona flexibilidad operacional para responder rápidamente a cambios en APIs externas.
- Garantiza validación temprana de configuración evitando fallos en runtime por configuraciones incorrectas.

---

### Decisión 2:

**Título**
- Enlace diferido de adaptadores de proveedores según demanda y disponibilidad

**Contexto**
- No todos los usuarios utilizan todos los proveedores disponibles (algunos solo usan Spotify, otros Apple Music).
- Los proveedores pueden estar temporalmente no disponibles por mantenimiento o problemas de red.
- Se busca optimizar recursos y mejorar el tiempo de startup del servicio.

**Alternativas**
- Inicializar todos los adaptadores al startup independientemente de su uso.
- Cargar adaptadores de forma lazy solo cuando el usuario los necesita.
- Implementar un sistema híbrido con pre-carga configurable y lazy loading como fallback.

**Criterios de Elección**
- Eficiencia de recursos: evitar inicialización innecesaria de componentes no utilizados.
- Tiempo de respuesta: minimizar latencia en la primera operación con cada proveedor.
- Resilencia: manejar fallos de proveedores sin afectar otros servicios.
- Observabilidad: visibilidad sobre qué proveedores están activos y disponibles.

**Decisión**
- **Implementar lazy loading de adaptadores con pre-warming configurable y circuit breaker por proveedor, permitiendo degradación grácil cuando proveedores no están disponibles.**

**Sustento**
- Optimiza el uso de recursos al cargar solo adaptadores necesarios según patrones de uso reales.
- Mejora la resilencia del sistema mediante circuit breakers que aíslan fallos de proveedores específicos.
- Mantiene flexibilidad operacional al permitir habilitar/deshabilitar proveedores dinámicamente según disponibilidad.

---

### Decisión 3:

**Título**
- Enlace temporal de políticas de rate limiting y retry según patrones de uso y respuesta de APIs

**Contexto**
- Diferentes APIs tienen límites de tasa variables y pueden cambiar sus políticas sin previo aviso.
- Los patrones de uso de LYRA pueden crear picos de tráfico que requieren ajustes dinámicos de estrategias de retry.
- Se necesita balancear agresividad de reintentos con respeto a los límites de las APIs externas.

**Alternativas**
- Usar políticas fijas de rate limiting configuradas estáticamente.
- Implementar algoritmos adaptativos que ajusten parámetros según respuestas de APIs.
- Sistema híbrido con configuración base y ajustes dinámicos con límites de seguridad.

**Criterios de Elección**
- Adaptabilidad: responder dinámicamente a cambios en comportamiento de APIs externas.
- Estabilidad: evitar oscilaciones que degraden el servicio.
- Observabilidad: métricas claras sobre efectividad de estrategias de retry.
- Seguridad: límites que eviten saturar APIs externas incluso en condiciones anómalas.

**Decisión**
- **Implementar sistema de políticas adaptativas con configuración base, ajuste automático basado en métricas de respuesta (latencia, tasa de error) y límites máximos de seguridad no modificables.**

**Sustento**
- Maximiza la eficiencia al adaptar automáticamente las estrategias de retry según el comportamiento real de las APIs.
- Garantiza estabilidad mediante límites de seguridad que previenen comportamientos degenerativos.
- Proporciona observabilidad detallada para optimización continua de las políticas de integración.

---

[⬅️ Anterior](../4.4/4.4.md) | [🏠 Home](../../README.md) | [Siguiente ➡️](../4.6/4.6.md)