> [8. Aplicaci√≥n de Patrones Arquitecturales](../8.md) ‚Ä∫ [8.4. M√≥dulo 4 / Integrante 4](8.4.md)

# 8.4. M√≥dulo Gesti√≥n de Preferencias de Usuario / Carolina Meza

## Introducci√≥n  

El M√≥dulo de Gesti√≥n de Preferencias de Usuario centraliza la configuraci√≥n personalizable de la aplicaci√≥n: tema, idioma, accesibilidad, layouts, calidad de reproducci√≥n, notificaciones opt-in/opt-out y consentimientos de tracking.  

Las preferencias son un dominio **read-heavy**, sensible a la latencia y con necesidades de **versionado, auditor√≠a y resoluci√≥n jer√°rquica** (global, app, tenant, usuario, dispositivo). Por ello se define un microservicio especializado (Preferences Service) con su propio modelo de datos h√≠brido y mecanismos de cach√© y eventos, desacoplado de Perfil y Autenticaci√≥n.  

---
## Patrones de M√≥dulo  

### Microservicio de Preferencias Independiente (Preferences Service)  

**Objetivo:** Aislar el dominio de preferencias para permitir evoluci√≥n r√°pida de esquema, auditor√≠a y escalamiento de lecturas.  

- **Descripci√≥n:**  
  El m√≥dulo se implementa como un **microservicio independiente** con su propio datastore y API REST, responsable de:  
  - CRUD de preferencias.  
  - Versionado e historial de cambios por usuario y dispositivo.  
  - Resoluci√≥n del valor efectivo considerando jerarqu√≠a de scopes.  

- **Aplicaci√≥n en el m√≥dulo:**  
  - Se separa expl√≠citamente de User Profile y Auth.  
  - Expone APIs especializadas para lectura ‚Äúr√°pida‚Äù (`getEffectivePreferences`) y escritura con auditor√≠a (`updatePreferences`).  

- **Beneficio:**  
  - Menor acoplamiento, despliegue independiente y escalamiento focalizado en lecturas.  
  - Posibilidad de cambiar el modelo interno (esquema, claves) sin impactar otros dominios cr√≠ticos.  

### Modelo de Datos H√≠brido: Key-Value Tipado + Entidades Reguladas  

**Objetivo:** Combinar flexibilidad para preferencias generales con control estricto para √°mbitos regulados (p. ej., privacidad).  

- **Descripci√≥n:**  
  Se utiliza un modelo h√≠brido:  
  - **Documento/JSON (key-value tipado)** para preferencias generales (tema, idioma, accesibilidad, layouts).  
  - **Esquema relacional normalizado** para consentimientos y flags sujetos a normativa (tracking, marketing, privacidad).  

- **Aplicaci√≥n en el m√≥dulo:**  
  - Tabla `user_preferences` con JSONB tipado y validado por esquema.  
  - Tablas `regulated_preferences` (o equivalente) para consentimientos por categor√≠a, con referencias a usuario/tenant y auditor√≠a de cambios.  

- **Beneficio:**  
  - Alta velocidad de cambio en preferencias de UX sin migraciones pesadas.  
  - Trazabilidad y cumplimiento normativo en datos sensibles.  

---  

## Patrones de Componente y Conector  

### API REST Tipada con NestJS + DTOs Validados  

**Objetivo:** Exponer contratos claros y consistentes entre clientes y el servicio de preferencias.  

- **Descripci√≥n:**  
  El backend se implementa en **NestJS (Node.js + TypeScript)**, usando m√≥dulos, inyecci√≥n de dependencias y DTOs validados (class-validator/Zod) con documentaci√≥n OpenAPI autogenerada.  

- **Aplicaci√≥n en el m√≥dulo:**  
  - Controladores REST para operaciones de preferencias (lectura, actualizaci√≥n, historial).  
  - Guards para autenticaci√≥n/autorizaci√≥n delegada desde el gateway o Auth Service.  
  - Pipes de validaci√≥n que garantizan tipos correctos, rangos v√°lidos y claves conocidas.  

- **Beneficio:**  
  - Contratos estables y f√°cilmente consumibles por web, mobile y otros servicios.  
  - Menor deuda t√©cnica y mejor cobertura de pruebas.  

### Cach√© de Preferencias + Pub/Sub de Invalidaci√≥n y Bus de Eventos  

**Objetivo:** Reducir latencia de lectura y propagar cambios de preferencias a otros servicios.  

- **Descripci√≥n:**  
  Se combina una cach√© en **Redis** con un canal de **Pub/Sub** para invalidaci√≥n y un **bus de eventos** (Kafka/NATS) para notificar cambios a servicios dependientes (Notificaciones, Recomendador, Analytics).  

- **Aplicaci√≥n en el m√≥dulo:**  
  - Lecturas frecuentes (`getEffectivePreferences`) se resuelven desde Redis, con TTL corto.  
  - Al modificar preferencias, el servicio:  
    - Actualiza la base de datos.  
    - Invalida la entrada de cach√© v√≠a canal Pub/Sub.  
    - Publica un evento `preference.changed` en el bus usando Transactional Outbox.  

- **Beneficio:**  
  - Latencias bajas en P95 para lectura de preferencias.  
  - Desacoplamiento entre el m√≥dulo de preferencias y consumidores secundarios (notificaciones, ML, marketing).  

---  

## Patrones de Asignaci√≥n  

### Jerarqu√≠a de Scopes y Llave Compuesta para Resoluci√≥n de Preferencias  

**Objetivo:** Resolver el ‚Äúvalor efectivo‚Äù de una preferencia considerando distintos √°mbitos (global, app, tenant, usuario, dispositivo) de forma determin√≠stica.  

- **Descripci√≥n:**  
  Se define una **jerarqu√≠a de resoluci√≥n**:  
  `default global ‚Üí app ‚Üí tenant/espacio ‚Üí usuario ‚Üí dispositivo`.  

  El modelo relacional incorpora una **llave compuesta**:  
  `(user_id, scope_type, scope_id, pref_key)` con columnas para `value` y `effective_value`.  

- **Aplicaci√≥n en el m√≥dulo:**  
  - En lectura, el servicio calcula el valor efectivo recorriendo la jerarqu√≠a de scopes.  
  - La API retorna tanto el valor efectivo como el `source_scope` (de d√≥nde proviene).  

- **Beneficio:**  
  - Experiencia consistente entre dispositivos, con posibilidad de overrides locales.  
  - Facilita la depuraci√≥n y la auditor√≠a (se puede explicar por qu√© un usuario ve un valor concreto).  

### Asignaci√≥n de Datastore: PostgreSQL con JSONB + √çndices GIN  

**Objetivo:** Garantizar transacciones ACID, relaciones fuertes y consultas eficientes sobre campos flexibles.  

- **Descripci√≥n:**  
  Se elige **PostgreSQL** como datastore principal, aprovechando soporte nativo de **JSONB** e √≠ndices **GIN**:  
  - Relaci√≥n fuerte con usuarios, tenants y dispositivos.  
  - Operadores JSON para filtrar por claves, tipos y √°mbitos.  

- **Aplicaci√≥n en el m√≥dulo:**  
  - `user_preferences` con JSONB e √≠ndices GIN por `pref_key` y filtros `(user_id, scope)`.  
  - Tablas normalizadas para consentimientos y banderas reguladas.  

- **Beneficio:**  
  - Consistencia fuerte, integridad referencial y flexibilidad en el mismo motor.  
  - Buen rendimiento en lecturas masivas y filtradas.  

---  

## Patrones de Tiempo de Enlace  

### Cat√°logo de Claves Versionado: Snapshot en Build + Hot Reload Controlado  

**Objetivo:** Gestionar el cat√°logo de claves de preferencias (tipo, default, validadores, rangos) con estabilidad y posibilidad de ajustes operativos.  

- **Descripci√≥n:**  
  El cat√°logo de claves se empaqueta como **snapshot** dentro de la imagen en tiempo de **build**, y se permite recarga en runtime desde un Config Service o blob firmado, controlada por feature flag.  

- **Aplicaci√≥n en el m√≥dulo:**  
  - Cada versi√≥n de la imagen incluye una versi√≥n del cat√°logo.  
  - La recarga opcional permite ajustar defaults o metadatos sin reconstruir la imagen, logueando versi√≥n y cambios para auditor√≠a.  

- **Beneficio:**  
  - Reproducibilidad por versi√≥n y facilidad para rollbacks.  
  - Flexibilidad para operaciones sin sacrificar control.  

### Enlace Diferido de Consumidores de Eventos y Degradaci√≥n Controlada  

**Objetivo:** Asegurar que el CRUD de preferencias funcione incluso ante fallas del bus de eventos o de consumidores anal√≠ticos.  

- **Descripci√≥n:**  
  Se emplea el patr√≥n **Transactional Outbox** y un **worker as√≠ncrono** para publicar eventos, con reintentos y Dead Letter Queue (DLQ). Si el bus o consumidores fallan, se degrada a ‚Äúsolo DB + cach√©‚Äù mediante circuit breaker.  

- **Aplicaci√≥n en el m√≥dulo:**  
  - Escrituras de preferencias confirman cuando la transacci√≥n en DB se completa; la publicaci√≥n de eventos se resuelve asincr√≥nicamente.  
  - Si la infraestructura de eventos est√° ca√≠da, las preferencias siguen operando; los mensajes pendientes se reenv√≠an cuando el servicio se recupera.  

- **Beneficio:**  
  - Resiliencia ante fallas externas sin afectar la experiencia del usuario.  
  - Garant√≠a de entrega al menos una vez para flujos de Analytics/ML y marketing.  

---  

## Conclusiones  

El M√≥dulo de Gesti√≥n de Preferencias de Usuario se dise√±a como un microservicio especializado con resoluci√≥n jer√°rquica de scopes y contratos bien definidos.  

La combinaci√≥n de **microservicio independiente**, **modelo de datos h√≠brido (JSONB + relacional)**, **NestJS tipado**, **cach√© Redis + eventos** y **patrones de tiempo de enlace** orientados a cat√°logo e integraciones opcionales garantiza:  

- Baja latencia en lectura de preferencias.  
- Evoluci√≥n r√°pida de claves y estructuras sin afectar dominios cr√≠ticos.  
- Cumplimiento normativo y trazabilidad para consentimientos.  
- Resiliencia y desacoplamiento frente a servicios de anal√≠tica y marketing.  

**Patrones aplicados:**  
- Microservicio de preferencias independiente.  
- Modelo h√≠brido key-value tipado + entidades reguladas.  
- Jerarqu√≠a de scopes y llave compuesta para resoluci√≥n.  
- API REST tipada con NestJS y DTOs validados.  
- PostgreSQL con JSONB + √≠ndices GIN.  
- Cach√© Redis + Pub/Sub de invalidaci√≥n.  
- Transactional Outbox + bus de eventos (`preference.changed`).  
- Cat√°logo de claves versionado (build + hot reload).  
- Integraciones opcionales controladas por entorno/secret manager.  
- Degradaci√≥n funcional ante fallos del bus (solo DB + cach√©).  


[‚¨ÖÔ∏è Anterior](../8.3/8.3.md) | [üè† Home](../../README.md) | [Siguiente ‚û°Ô∏è](../8.5/8.5.md)